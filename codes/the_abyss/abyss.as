package  {		import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.display.DisplayObject;		import flash.geom.Rectangle;	import flash.geom.Point;	import flash.geom.ColorTransform;				import flash.utils.ByteArray;		//as3kinect (OpenKinect) libraries	import org.as3kinect.as3kinect;	import org.as3kinect.as3kinectWrapper;	import org.as3kinect.as3kinectUtils;	import org.as3kinect.events.as3kinectWrapperEvent;	import org.as3kinect.objects.motorData;		import flash.events.MouseEvent;	import flash.events.Event;	import flash.events.TouchEvent		import flash.display.MovieClip;	public class TheAbyss extends MovieClip{		//My variables		private var users:Array;		private var animals:Array;		private var bg:MovieClip;		//Instanciating the wrapper library		private var as3w:as3kinectWrapper = new as3kinectWrapper();		//Canvas variables		private var canvas_depth:BitmapData;		private var bmp_depth:Bitmap;		private var canvas_video:BitmapData;		private var bmp_video:Bitmap;				public function TheAbyss(){			users = new Array;			animals = new Array;			bg = new MovieClip;								//Add as3kinectWrapper events (depth, video and acceleration data)			as3w.addEventListener(as3kinectWrapperEvent.ON_DEPTH, gotdepth);			as3w.addEventListener(as3kinectWrapperEvent.ON_VIDEO, gotvideo);			as3w.addEventListener(as3kinectWrapperEvent.ON_ACCELEROMETER, gotmotordata);			//Add depth BitmapData to depthcam MovieClip			as3w.depth.mirrored = true;			canvas_depth = as3w.depth.bitmap;			bmp_depth = new Bitmap(canvas_depth);			depthcam.removeChildAt(0);			depthcam.addChild(bmp_depth);						//Add video BitmapData to rgbcam MovieClip			as3w.video.mirrored = true;			canvas_video = as3w.video.bitmap;			bmp_video = new Bitmap(canvas_video);			rgbcam.removeChildAt(0);			rgbcam.addChild(bmp_video);						//On every frame call the update method			stage.addEventListener(Event.ENTER_FRAME, update);			animals.append(new Animal());			addChild(angler());			trace('i got here');		}				//UPDATE METHOD (This is called each frame)		private function update(event:Event){			as3w.video.getBuffer();			as3w.depth.getBuffer();			as3w.motor.getData();		}				//GOT DEPTH METHOD		private function gotdepth(event:as3kinectWrapperEvent):void{			//Convert Received ByteArray into BitmapData			as3kinectUtils.byteArrayToBitmapData(event.data, canvas_depth);			//Transform to Black / White image for blob detection			//if(true) as3kinectUtils.setBlackWhiteFilter(canvasdepth, (60/100)* 256);			if(true) { 				//Process Blobs from image				blobarray = as3kinectUtils.getBlobs(canvas_depth);				//Send pointers somwhere we cant see them				/*				for(var i = 0, max = pointer.length; i < max; i++){					//pointer[i].x = -10;				}				*/				//Create pointers if not enough and position them in the bottom center of the blob rect				for(i = 0, max = blobarray.length; i < max; i++)				{					if(User[i] == undefined) { 						User[i] = new User(blobarray[i].point.x, blobarray[i].point.y,blobarray[i].rect.width;);						//User[i].stop();						//addChild(User[i]);					}					pointer[i].x = blobarray[i].point.x;					pointer[i].y = blobarray[i].rect.y + 10;					//Fire touch event where the pointer is					//as3kinectUtils.fireTouchEvent(i , new Point(pointer[i].x, pointer[i].y), touchdata, stage);					if(User[i].x > 0 && User[i].y > 0)						touching(User[i]);				}			}		}				//GOT VIDEO METHOD		private function gotvideo(event:as3kinectWrapperEvent):void{			//Convert Received ByteArray into BitmapData			as3kinectUtils.byteArrayToBitmapData(event.data, canvas_video);		}				//GOT MOTOR DATA (Accelerometer info)		private function gotmotordata(event:as3kinectWrapperEvent):void		{			var object:motorData = event.data;			info.text = "raw acceleration:\n\tax: " + object.ax + "\n\tay: " + object.ay;			info.appendText("\n\taz: " + object.az + "\n\n");			info.appendText("mks acceleration:\n\tdx: " + object.dx + "\n\tdy: " + object.dy);			info.appendText("\n\tdz: " + object.dz + "\n");		}				private function touching(cur, i):void{			var curX:int = cur.x;			var curY:int = cur.y;						curX = (curX / 640) * stage.width;			curY = (curY / 480) * stage.height;						trace(curX+', '+curY);						if(curX> prevX[i]){				cur.gotoAndStop(10);			}			else if(curX < prevX[i]){				cur.gotoAndStop(30);			}			cur.x = curX;			cur.y = curY;			prevX[i] = curX;			prevY[i] = curY;		}	}	}